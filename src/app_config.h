#pragma once

#include <string>
#include <vector>
#include <map>

#include "umba/program_location.h"
#include "umba/enum_helpers.h"
#include "umba/flag_helpers.h"
#include "umba/regex_helpers.h"
#include "umba/filename.h"

#include <time.h>

#include "marty_cpp/marty_cpp.h"
#include "marty_cpp/src_normalization.h"

#include "mimes.h"
#include "cppHelpers.h"

#include "2c_common/_2c_xor_encrypt.h"


//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
struct AppConfig
{
    // umba-2c & umba-2rcfs commons
    //bool                                     quet       = false;
    bool                                     bOverwrite           = false  ; //!< Overwrite output file, if exist
    bool                                     disableEndLinefeed   = false  ; //!< Do not add linefeed at the end of text
    bool                                     dontKeepExt          = false  ; //!< Remove file extention from autogenerated C-lang var name
    bool                                     binInput             = false  ; //<! Input is binary
    //std::string                              outputLineSep                 ; //<! Output line separator (for data)

    marty_cpp::ELinefeedType                 outputLineFeed       = marty_cpp::ELinefeedType::detect;

    bool                                     outputAsString       = false  ; //!< Generate output as C-string, else - array of HEXs
    size_t                                   lineSize             = 0      ; //!< Set max line size or number of array items per line
    bool                                     staticArray          = false  ; //!< Generate static data
    bool                                     nonConstArray        = false  ; //!< Generate non-const data
    bool                                     decFormat            = false  ; //!< Use decimal format for array items (default is hex)
    bool                                     compressWhitespaces  = false  ; //!< Compress whitespaces - reduce multiple WS (\\s, \\t) to single
    bool                                     trimLines            = false  ; //!< Trim lines at right - remove trailing spaces

    std::string                              cname                         ; //!< C-array/string name, override auto-generated from file name

    std::string                              inputEnc                      ; //!< Set input encoding (for text data)
    std::string                              outputEnc            = "UTF-8"; //!< Set target encoding

    bool                                     addMimeType          = false  ; //!< Set mime type
    std::string                              mimeType             = ""     ; //!< Set mime type as taken. If no mime type explicitly taken, it will be autodetected

    bool                                     addLastModified      = false  ; //!< Set last-modified
    std::string                              lastModified         = ""     ; //!< Set last-modified as taken. If not explicitly taken, it will be generated by strftime("%a, %d %b %Y %H:%M:%S GMT")

    bool                                     addResourceFileName  = false  ; //!< Add resource file name variable
    std::string                              resourceFileName              ; //!< Add resource file name. Parameter value is optional, autogenerated on filename, if not explicitly taken

    bool                                     addResourceFileSize  = false  ; //!< Add resource size variable

    bool                                     generateClass        = false  ; //!< Generate class CLASSNAME for resource
    std::string                              className                     ; //!< class name

    std::vector< std::string >               classNamespaces               ; //!< 

    bool                                     generateHeader       = false  ; //!< Generate header file (.h) instead of .c

    bool                                     base64               = false  ; //!< Encode input file into base64
    int                                      base64LineLen        = 0      ; //!< Set base64 encoded line max len
    bool                                     base64Filling        = false  ; //!< Add base64 filling chars at end

    _2c::EKeySize                            xorEncKeySize        = _2c::EKeySize::Unknown; //!< Encrypt input file with simple XOR encryption.
    unsigned                                 xorEncSeed           = 0                     ; //!< 
    unsigned                                 xorEncInc            = 0                     ; //!< 


    // Только для umba-2rcfs
    bool                                     allFiles = false;
    // bool                                     scanMode = false; // хз откуда взялось
    std::vector<std::string>                 scanPaths;
    std::vector<std::string>                 includeFilesMaskList;
    std::vector<std::string>                 excludeFilesMaskList;


    static
    std::string textAppend(std::string text, const std::string &strAppend)
    {
        if (!text.empty() && !strAppend.empty())
        {
            text.append(1, ' ');
        }
    
        text.append(strAppend);
    
        return text;
    }

    void adjust_mimeType(const std::string &inputFilename)
    {
        if (addMimeType)
        {
            if (mimeType.empty())
            {
                //NOTE: !!! А оно надо, toLower?
                //std::string srcExt = toLower(umba::filename::getFileExtention(inputFilename));
                // std::string srcExt = umba::filename::getFileExtention(inputFilename);
                std::string srcExt = marty_cpp::toLower(umba::filename::getFileExtention(inputFilename));
                if (!srcExt.empty() && srcExt[0]!='.')
                   srcExt = std::string(".") + srcExt;
    
                const std::map< std::string, std::string >& mimes = getMimeTypes();
                std::map< std::string, std::string >::const_iterator mit = mimes.find(srcExt);
                if (mit==mimes.end())
                    mimeType = "application/octet-stream";
                else
                    mimeType = mit->second;
            }
        }

    }

    //! Requires full name with path
    void adjust_lastModified(const std::string &inputFilename)
    {
        if (addLastModified)
        {
            if (lastModified.empty())
            {
                struct stat t_stat;
                stat(inputFilename.c_str(), &t_stat);
                struct tm * timeinfo = gmtime(&t_stat.st_mtime); // or st_mtim? st_ctime or localtime() depending on what you want
    
                // asctime - Www Mmm dd hh:mm:ss yyyy\n
                // http    - <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
                // https://en.cppreference.com/w/cpp/chrono/c/strftime
               
                char buf[256];
                std::size_t sz = strftime( buf, sizeof(buf), "%a, %d %b %Y %H:%M:%S GMT", timeinfo );
                buf[sz] = 0;
    
                lastModified = buf;
            }
        }
    }

    void adjust_resourceFileName(const std::string &inputFilename)
    {
        if (addResourceFileName)
        {
            if (resourceFileName.empty())
            {
                resourceFileName = umba::filename::getFileName(inputFilename);
            }
        }
    }

    //! cname - C-array/string name, override auto-generated from file name
    void adjust_cname(const std::string &inputFilename)
    {
        if (cname.empty())
        {
            if (!dontKeepExt)
                cname = makeCppName(umba::filename::getFileName(inputFilename));
            else
                cname = makeCppName(umba::filename::getName(inputFilename));
        }
    
        if (!cname.empty())
        {
            // if (appConfig.cname[0]>='0' && appConfig.cname[0]<='9')
            //     appConfig.cname = std::string("_") + appConfig.cname;
            cname = marty_cpp::fixName(cname, true /* fixStartDigit */  /* , forceAllowedChars */ );
        }
    
    }

    void adjust_outputAsString()
    {
        if (xorEncKeySize!=_2c::EKeySize::Unknown)
        {
            outputAsString = false;
        }
    }


    //! Set target encoding
    void adjust_outputEnc()
    {
        if (outputEnc.empty())
            outputEnc = "UTF-8";
    }

    void adjust_trim()
    {
        if (compressWhitespaces)
            trimLines = true;
    }

    void adjust(const std::string &inputFilename)
    {
        adjust_mimeType(inputFilename);
        adjust_lastModified(inputFilename);
        adjust_resourceFileName(inputFilename);
        adjust_cname(inputFilename);
        adjust_outputAsString();
        adjust_outputEnc();
        adjust_trim();
    }

    AppConfig adjusted(const std::string &inputFilename) const
    {
        AppConfig cfgCopy = *this;
        cfgCopy.adjust(inputFilename);
        return cfgCopy;
    }

    std::string getAdustedOutputFilename(const std::string &inputFilename, std::string outputFilename) const
    {
        if (!outputFilename.empty())
            return outputFilename;

        outputFilename = umba::filename::getPathFile( inputFilename );
        std::string ext = umba::filename::getFileExtention( inputFilename );
        if (!ext.empty())
            outputFilename += std::string("_") + ext;
        outputFilename = umba::filename::appendExtention( outputFilename, std::string("c") );

        return outputFilename;
    }

    std::string xorEncrypt(std::string data) const
    {
        if (xorEncKeySize==_2c::EKeySize::Unknown)
        {
            return data;
        }

        _2c::xorEncrypt(data.begin(), data.end(), xorEncKeySize, xorEncSeed, xorEncInc);

        return data;
    }

    std::string normalizeLinefeeds(const std::string &text) const
    {
        if (binInput)
        {
            return text;
        }

        switch(outputLineFeed)
        {
            case marty_cpp::ELinefeedType::lf  :
            case marty_cpp::ELinefeedType::cr  :
            case marty_cpp::ELinefeedType::lfcr:
            case marty_cpp::ELinefeedType::crlf:
            {
                std::string textLfNormalized   = marty_cpp::normalizeCrLfToLf(text);
                std::vector<std::string> lines = marty_cpp::splitToLinesSimple(textLfNormalized, true /* addEmptyLineAfterLastLf */, '\n' /* lfChar */ );
                return mergeLines(lines, outputLineFeed, false /* addTrailingNewLine */);
            }

            default: return text;
        }
    }

    std::string getArrayTypeName() const
    {
        return outputAsString ? "char" : "unsigned char";
    }
    
    std::string getStaticConst() const
    {
        std::string staticConst;
        if (staticArray)
           staticConst = textAppend(staticConst, "static"); // std::string("static ") + staticConst;
        if (!nonConstArray)
           staticConst = textAppend(staticConst, "const"); // std::string("const ") + staticConst;
        return staticConst;
    }


}; // struct AppConfig




