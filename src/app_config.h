#pragma once

#include <string>
#include <vector>
#include <map>

#include "umba/program_location.h"
#include "umba/enum_helpers.h"
#include "umba/flag_helpers.h"
#include "umba/regex_helpers.h"
#include "umba/filename.h"

#include <time.h>

#include "marty_cpp/marty_cpp.h"
#include "marty_cpp/src_normalization.h"

#include "mimes.h"
#include "cppHelpers.h"


//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
struct AppConfig
{
    // umba-2c & umba-2rcfs commons
    //bool                                     quet       = false;
    bool                                     bOverwrite           = false  ; //!< Overwrite output file, if exist
    bool                                     disableEndLinefeed   = false  ; //!< Do not add linefeed at the end of text
    bool                                     dontKeepExt          = false  ; //!< Remove file extention from autogenerated C-lang var name
    bool                                     binInput             = false  ; //<! Input is binary
    std::string                              outputLineSep                 ; //<! Output line separator (for data)
    bool                                     outputAsString       = false  ; //!< Generate output as C-string, else - array of HEXs
    size_t                                   lineSize             = 0      ; //!< Set max line size or number of array items per line
    bool                                     staticArray          = false  ; //!< Generate static data
    bool                                     nonConstArray        = false  ; //!< Generate non-const data
    bool                                     decFormat            = false  ; //!< Use decimal format for array items (default is hex)
    bool                                     compressWhitespaces  = false  ; //!< Compress whitespaces - reduce multiple WS (\\s, \\t) to single
    bool                                     trimLines            = false  ; //!< Trim lines at right - remove trailing spaces

    std::string                              cname                         ; //!< C-array/string name, override auto-generated from file name

    std::string                              inputEnc                      ; //!< Set input encoding (for text data)
    std::string                              outputEnc            = "UTF-8"; //!< Set target encoding

    bool                                     addMimeType          = false  ; //!< Set mime type
    std::string                              mimeType             = ""     ; //!< Set mime type as taken. If no mime type explicitly taken, it will be autodetected

    bool                                     addLastModified      = false  ; //!< Set last-modified
    std::string                              lastModified         = ""     ; //!< Set last-modified as taken. If not explicitly taken, it will be generated by strftime("%a, %d %b %Y %H:%M:%S GMT")

    bool                                     addResourceFileName  = false  ; //!< Add resource file name variable
    std::string                              resourceFileName              ; //!< Add resource file name. Parameter value is optional, autogenerated on filename, if not explicitly taken

    bool                                     addResourceFileSize  = false  ; //!< Add resource size variable

    bool                                     generateClass        = false  ; //!< Generate class CLASSNAME for resource
    std::string                              className                     ; //!< class name

    std::vector< std::string >               classNamespaces               ; //!< 

    bool                                     generateHeader       = false  ; //!< Generate header file (.h) instead of .c

    bool                                     base64               = false  ; //!< Encode input file into base64
    int                                      base64LineLen        = 0      ; //!< Set base64 encoded line max len
    bool                                     base64Filling        = false  ; //!< Add base64 filling chars at end

    _2c::EKeySize                            xorEncKeySize        = _2c::EKeySize::Unknown; //!< Encrypt input file with simple XOR encryption.
    unsigned                                 xorEncSeed           = 0                     ; //!< 
    unsigned                                 xorEncInc            = 0                     ; //!< 


    // Только для umba-2rcfs
    bool                                     allFiles = false;
    // bool                                     scanMode = false; // хз откуда взялось
    std::vector<std::string>                 scanPaths;
    std::vector<std::string>                 includeFilesMaskList;
    std::vector<std::string>                 excludeFilesMaskList;



    void adjust_mimeType(const std::string &inputFilename)
    {
        if (addMimeType)
        {
            if (mimeType.empty())
            {
                //NOTE: !!! А оно надо, toLower?
                //std::string srcExt = toLower(umba::filename::getFileExtention(inputFilename));
                // std::string srcExt = umba::filename::getFileExtention(inputFilename);
                std::string srcExt = marty_cpp::toLower(umba::filename::getFileExtention(inputFilename));
                if (!srcExt.empty() && srcExt[0]!='.')
                   srcExt = std::string(".") + srcExt;
    
                const std::map< std::string, std::string >& mimes = getMimeTypes();
                std::map< std::string, std::string >::const_iterator mit = mimes.find(srcExt);
                if (mit==mimes.end())
                    mimeType = "application/octet-stream";
                else
                    mimeType = mit->second;
            }
        }

    }

    //! Requires full name with path
    void adjust_lastModified(const std::string &inputFilename)
    {
        if (addLastModified)
        {
            if (lastModified.empty())
            {
                struct stat t_stat;
                stat(inputFilename.c_str(), &t_stat);
                struct tm * timeinfo = gmtime(&t_stat.st_mtime); // or st_mtim? st_ctime or localtime() depending on what you want
    
                // asctime - Www Mmm dd hh:mm:ss yyyy\n
                // http    - <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
                // https://en.cppreference.com/w/cpp/chrono/c/strftime
               
                char buf[256];
                std::size_t sz = strftime( buf, sizeof(buf), "%a, %d %b %Y %H:%M:%S GMT", timeinfo );
                buf[sz] = 0;
    
                lastModified = buf;
            }
        }
    }

    void adjust_resourceFileName(const std::string &inputFilename)
    {
        if (addResourceFileName)
        {
            if (resourceFileName.empty())
            {
                resourceFileName = umba::filename::getFileName(inputFilename);
            }
        }
    }

    //! cname - C-array/string name, override auto-generated from file name
    void adjust_cname(const std::string &inputFilename)
    {
        if (cname.empty())
        {
            if (!dontKeepExt)
                cname = makeCppName(umba::filename::getFileName(inputFilename));
            else
                cname = makeCppName(umba::filename::getName(inputFilename));
        }
    
        if (!cname.empty())
        {
            // if (appConfig.cname[0]>='0' && appConfig.cname[0]<='9')
            //     appConfig.cname = std::string("_") + appConfig.cname;
            cname = marty_cpp::fixName(cname, true /* fixStartDigit */  /* , forceAllowedChars */ );
        }
    
    }

    void adjust(const std::string &inputFilename)
    {
        adjust_mimeType(inputFilename);
        adjust_lastModified(inputFilename);
        adjust_resourceFileName(inputFilename);
        adjust_cname(inputFilename);
    }

    AppConfig adjusted(const std::string &inputFilename) const
    {
        AppConfig cfgCopy = *this;
        cfgCopy.adjust(inputFilename);
        return cfgCopy;
    }


    // bool                                     addResourceFileSize  = false  ; //!< Add resource size variable
    //  
    // bool                                     generateClass        = false  ; //!< Generate class CLASSNAME for resource
    // std::string                              className                     ; //!< class name
    //  
    // std::vector< std::string >               classNamespaces               ; //!< 
    //  
    // bool                                     generateHeader       = false  ; //!< Generate header file (.h) instead of .c
    //  
    // bool                                     base64               = false  ; //!< Encode input file into base64
    // int                                      base64LineLen        = 0      ; //!< Set base64 encoded line max len
    // bool                                     base64Filling        = false  ; //!< Add base64 filling chars at end
    //  
    // _2c::EKeySize                            xorEncKeySize        = _2c::EKeySize::Unknown; //!< Encrypt input file with simple XOR encryption.
    // unsigned                                 xorEncSeed           = 0                     ; //!< 
    // unsigned                                 xorEncInc            = 0                     ; //!< 



}; // struct AppConfig




